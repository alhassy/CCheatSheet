# (org-latex-export-to-pdf)

#+TITLE: C Language CheatSheet
#+MACRO: URL https://github.com/alhassy/CCheatSheet
#+MACRO: blurb Basics of the tremendously ubiquitous C language that permeates most of computing!
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+TODO: Todo | spacing begin end LaTeX
#+OPTIONS: d:nil
#+INCLUDE: CheatSheet/CheatSheetSetup.org
#+PROPERTY: header-args :results replace

:Nope:
#+BEGIN_SRC C
enum days {SUN = 1, MON, TUE, WED, THU, FRI, SAT};
// Automatically: MON = 2, TUE = 3, ‚Ä¶.
#+END_SRC
:End:

:EmacsSetup:

See [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][here]] for working with C/C++/D code blocks in Org mode;
which includes examples and header argument configurations.

+ If a main method is not present in a code block then the entire block is wrapped in a trivial main function call.

+ If you want to see the expanded source code, without compiling and running it, just type C-c C-v v.

:var VARIABLE=VALUE
A global C, C++, or D variable named VARIABLE will be declared and initialized with VALUE

Possible types for VARIABLE may be:

int,
double,
string or const char*,
type[]    // type = int, double, string, const char*
type[][]  // type = int, double, string, const char*
The later type, type[][], is used for variables storing Org tables

The type[] is used for lists or vectors declared in the header.

+ ~:cmdline~ ::
	command line arguments to pass to the executable compiled from the code block.

+ ~:flags~ :: flags to pass to the compiler.

+ ~:main~ ::
	    can be set to "no" to inhibit wrapping of the code block in a main function call.

+ ~:includes~ :: accepts either a single string name, or a list of names of files to #include in the execution of the code block.

+ ~:defines~ :: just like :includes but for #defines lines at the top of the code.

+ ~:libs~ :: useful for linking with a library, may be given -L/path/to/lib and -llibrary instructions.

There is no support for sessions:
As opposed to interpreted languages, which can be evaluated directly, C, C++, and D code is first compiled to an executable which is then run.

+ There is no directive like ~#include "stdio.h"~ because those libraries are so common that they are always included.

+ Variables may be declared outside the script. They are automatically inserted at the top of the script.

#+NAME: nice
| English | Arabic |
|---------+--------|
| zero    | sifr   |
| one     | wahid  |
| two     | ithnan |

#+header: :var mystring="Sunday" :var myint=145 :var mydouble=3.14 :var T=nice
#+BEGIN_SRC C
  // T is decared as a char*  [][] array with helpers: T_rows, T_cols, T_header, and accessor function T_h(row, col). Press C-c C-v v to see these generated names ;-)
  printf ("mystring %s\n", mystring);
  printf ("myint    %d\n", myint);
  printf ("mydouble %g\n", mydouble);
  printf ("%s %s", T_h(1, "English"), T_h(1, "Arabic") );

  // When an org table only consists of numbers, then it will be typed double[][],
  // otherwise tables are always strings, to convert a string to a numeric value, use C's atoi.
#+END_SRC

#+RESULTS:
| mystring | Sunday |
| myint    |    145 |
| mydouble |   3.14 |
| one      |  wahid |

generated code visualization through C-c C-v v is super cool.

:End:

* LaTeX Extra, Local, Setup :ignore:

# Can be obtained from: https://github.com/alhassy/MyUnicodeSymbols
#
#+LATEX_HEADER: \usepackage{/Users/musa/MyUnicodeSymbols/MyUnicodeSymbols}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \newunicodechar{ùëª}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{‚âà}{\ensuremath{\approx}}

#+LATEX_HEADER: \newunicodechar{‚ü™}{\ensuremath{\langle\!\langle}}
#+LATEX_HEADER: \newunicodechar{‚ü´}{\ensuremath{\rangle\!\rangle}}

#+LATEX_HEADER: \newunicodechar{ùüò}{\ensuremath{\mathbb{0}}}

* COMMENT ~\LaTeX~ commands ‚Ü¶ ~#+latex: \LaTeX~

  Execute the following block, with ~C-c C-c~ anywhere inside it,
  to hide all LaTeX specific items away so that, for example, the generated HTML
  does not show them.

  #+BEGIN_SRC emacs-lisp :results no
(defun my/replace-in-buffer (this that)
  "Replace every occurance of regexp ‚Äòthis‚Äô with ‚Äòthat‚Äô
   in the current buffer."
   (interactive)
   (save-excursion
    (beginning-of-buffer)
    (while (re-search-forward this nil t)
      (replace-match that)
    ))
)

;; Replace newline, any number of space, then room or vspace with a #+latex: beforehand.
(let (this that)
  (dolist (kp '( ( "^[ ]*\\\\room" . "#+latex: \\\\room")
		 ( "^[ ]*\\\\vspace" . "#+latex: \\\\vspace")
		 ( "^[ ]*\\\\newpage" . "#+latex: \\\\newpage")
		 ( "^[ ]*\\\\columnbreak" . "#+latex: \\\\columnbreak")
		 ))
	(setq this (car kp))
	(setq that (cdr kp))
	(my/replace-in-buffer this that)
   )
)
  #+END_SRC

  #+RESULTS:


* Adminstriva

  + All C programs consist of a series of /functions/, which have return values!

  + E.g., Assignment ~x = v~ is the function that updates the value of name ~x~
	with the value of ~v~ then terminates yielding ~v~ as a return value.

  + Semicolons act as statement /terminators/ ---in contrast to English,
    wherein they are /separators/.

  + C is whitespace agnostic: Newlines and arbitrary spaces don't matter, for the most part.
    # Every token could be on its own line if we want.

  + /Compound statements/ are formed from primitive statements by enclosing them in ~{~ curly braces ~}~.
    - Compounds may appear where-ever a single statement is allowed.

  + All keywords are in lowercase.

  + C comments do /not/ nest.
  + Include files personal files by enclosing them in "quotes", use <brackets> for
    standard library files.
  + /All/ statements must terminate with a semicolon.
  + Everything must be declared before it can be used ---sequential.
  + Characters are in-fact aliases for ASCII numerals.
    #+BEGIN_SRC C :exports results
    printf("'A' ‚âà %d  ‚â°  %s", 'A', 'A' == 65? "true" : "false");
    #+END_SRC

    #+RESULTS:
    : 'A' ‚âà 65  ‚â°  true

  + C functions don't have to return anything if it's not appropriate.
    - E.g., ~exit(n)~ is the function that returns control to the operating system;
      passing it an argument ~n~, usually 0 if everything has gone smoothly and 1 if it's
      an error exit. Yet this function obviously' can't /return/ a value.

  + You must specify the type of a variable before you can use it.

  + A variable name is only meaningful in the curly brackets that define it,
    and is otherwise meaningless. This is its /scope/.
    - Whence, the same names can occur in different places to mean different things.
    - To transfer data between functions one thus uses parameter lists and return calls.

  + ~printf~, ‚Äúprint formatted‚Äù, is a /dependently-typed function/: The number and type
    of its arguments depends on its first argument, a string.
    + The number of occurrences of ‚Äò%‚Äô in the string argument is the number of additional arguments
      the ~printf~ takes.

* spacing newpage                                            :ignore:
#+latex: \newpage
* Conditionals & Assertion-Based Testing

  In C, /true ‚âà non-zero/.
  Form of the conditional:
  \vspace{-0.5em}
#+BEGIN_SRC C
if (condition)
  statementBlock
// The rest is optional.
else
  statementBlock
  #+END_SRC
  \vspace{-0.5em}
+ ~condition~ is /any/ expression that returns a numeric value:
  All numbers are treated as ‚Äòtrue‚Äô, except 0 which is considered ‚Äòfalse‚Äô.
  # - Ex, ~while(1) S~ means repeat ~S~ /forever/, or as much as possible.

  #+begin_center org
/Asserts are essentially compile-checked comments of user intentions!/
#+end_center

~assert(e)~ does nothing when expression ~e~ is true; otherwise it gives a message
showing the filename, function name, line number, and the condition ~e~ that
failed to be true.
# It is a macro defined in <assert.h>.

#+BEGIN_SRC C
#include <stdio.h>

// Disable assertions at compile time by enabling NODEBUG.
// #define NDEBUG

#include <assert.h>
// assert(n)  ‚âà  if (n) {} else ‚ü™Terminate and display error message‚ü´

int sum(int n)
{
  int total = 0, i = 0;
  while (i != n + 1)
    total += i, i++;

  return total;
}

int main ()
{
  // print-based testing
  if (1) printf("here"); else printf("there");
  printf("Sum of 0 + 1 + ‚ãØ + 99 + 100 = %d", sum(100));

  // assertion-based testing
  assert( sum(100) == 5050 );
  assert( (1 ? "here" : "there") == "here" );

  // Is completely ignored if the #define is enabled.
  // assert(0);  // Otherwise, this causes a crash.

  return 0;
}

#+END_SRC

#+RESULTS:
: hereSum of 0 + 1 + ‚ãØ + 99 + 100 = 5050

  \vspace{-0.5em}
Enforce a particular precedence order by enclosing expressions in parentheses.
#+BEGIN_SRC C
== equals          != differs from     !  not
>= at least        <= at most          && and
>  greater than    <  less than        || or
#+END_SRC

# The primary use of assertions is to ensure certain properties of data are true
# ---e.g., enforcing contracts: Checking conditions on inputs and outputs.

:Hide_my_assert:
Here's a handy utility for quick testing of my small examples.
#+BEGIN_SRC C :tangle "myassert.h" :main no
#define assert(e) int main () { printf("%s", e ? "true" : "false"); return 0; }
#+END_SRC

Example use:
#+BEGIN_SRC C :main no :includes '(\"/Users/musa/CCheatSheet/myassert.h\")
int f(n) { return n % 3; }

assert( f(0) == 0  &&  f(3) == 0  &&  f(23) == 2);
#+END_SRC

#+RESULTS:
: true

We see the results alongside writing a function, without having to form a ~main~
just to check these tests.
:End:

* spacing newpage                                            :ignore:
#+latex: \newpage

* Assignments

#+BEGIN_SRC C
/* Abbreviations */
  x ‚äï= y   ‚âà  x = x ‚äï y
  x++       ‚âà  x += 1
  --x      ‚âà  x -= 1
#+END_SRC

The increment and decrement, ~++/--~, operators may precede or follow a name:

+ If they follow a name, then their behaviour is executed /after/ the smallest context
  ---e.g., braces or conditional parentheses--- in which they occur.

+ When they precede a name, their behaviour is executed before the context in which
  they appear.

+ The order of evaluation is not specified inside a function call and so behaviour
  varies between compilers.

*Avoid using these in complex expressions, unless you know what you're doing.*

* Loops

  Here's the general form.
#+BEGIN_SRC C
while (condition)
  statementBlock

/* Abbreviations */
/* for      loop */   for(A; B; C;) S  ‚âà  A; while(B) S
/* do-while loop */   do S while B     ‚âà  S; while(B) S
#+END_SRC

do/while: The conditional is evaluated /after/ the statement has been executed
and so the statement is obeyed at least once, regardless of the truth or falsity of
the condition. This is useful for /do once, and possible more/ operations.
#+BEGIN_SRC C
int i = 0;
do printf("%d \n", i++);
while (i != 10); //Note the ending semicolon.
#+END_SRC
#+RESULTS:
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

* spacing newpage                                            :ignore:
#+latex: \newpage

* Arithmetic and Logic

#+begin_quote
/...and then the different branches of arithmetic ---Ambition, Distraction,
Uglification, and Derision./

---Alice's Adventures in Wonderland
#+end_quote

The modulus operator ~%~ gives the /remainder/ of a division.
#+BEGIN_SRC C :exports none
printf("rem = 10 %% 3 = %d  ‚áí  ‚àÉ quot ‚Ä¢  10 = 3 √ó quot + rem  ‚àß  quot = %d", 10 % 3, 10 / 3);
#+END_SRC

#+RESULTS:
: rem = 10 % 3 = 1  ‚áí  ‚àÉ quot ‚Ä¢  10 = 3 √ó quot + rem  ‚àß  quot = 3

+ In conditionals, one may see ~n % d~ to mean that ~n % d~ is true, i.e., is /non-zero/.
  This expresses that ~n~ is a /multiple/ of ~d~.

+ That is, numerically ~%~ yields remainders; but logically, in C, it expresses the
  is-multiple-of relationship.

When ~x~ is a number, the shift operations correspond to multiplication and
division by ~2‚Åø~, respectively.
| Left Shift  | ~x << n~ | append the bit representation of ~x~ with ~n~-many 0s             |
| Right Shift | ~x >> n~ | throw away ~n~ bits from the end of the bit representation of ~x~ |

The /bitwise/ operators /and ~&~, or ~|~, not ~!~,/ and /xor/ ~^~ operate at the bit representation
of an item. For example, the ASCII code of a character consists of 7 bits where
| _Bit_ | _Function_                            |
|   7 | 0 digit, 1 letter                   |
|   6 | 0 upper case, 1 digit or lower case |
|   5 | 0 for a-o, 1 for digit or p-z       |

Whence, to convert a character to uppercase it suffices to change bit 5 to be a 0
and leave the other bits alone. That is, to perform a bitwise /and/ with the binary
number /11011111/, which corresponds to the decimal number 223.

:Hide_binary_priniting:
From [[https://stackoverflow.com/a/3208376/3550444][stackoverflow]],
#+BEGIN_SRC C :tangle "BinaryPrinting.c" :main no
// Super buggy! E.g., try printing 1 ^ 1.

#define BinPat "%c%c%c%c%c%c%c%c"

#define ToBin(byte)  \
  ((unsigned int)byte & 0x80 ? '1' : '0'), \
  ((unsigned int)byte & 0x40 ? '1' : '0'), \
  ((unsigned int)byte & 0x20 ? '1' : '0'), \
  ((unsigned int)byte & 0x10 ? '1' : '0'), \
  ((unsigned int)byte & 0x08 ? '1' : '0'), \
  ((unsigned int)byte & 0x04 ? '1' : '0'), \
  ((unsigned int)byte & 0x02 ? '1' : '0'), \
  ((unsigned int)byte & 0x01 ? '1' : '0')

#define printBin(n) printf(BinPat, ToBin(n));
#+END_SRC

#+BEGIN_SRC C :includes '(<stdio.h> \"/Users/musa/CCheatSheet/BinaryPrinting.h\")
for(int i = 0; i < 11; i++)
  {printf("\n%d ‚áí ", i); printBin(i);}
#+END_SRC

#+RESULTS:
|  0 | ‚áí |    0 |
|  1 | ‚áí |    1 |
|  2 | ‚áí |   10 |
|  3 | ‚áí |   11 |
|  4 | ‚áí |  100 |
|  5 | ‚áí |  101 |
|  6 | ‚áí |  110 |
|  7 | ‚áí |  111 |
|  8 | ‚áí | 1000 |
|  9 | ‚áí | 1001 |
| 10 | ‚áí | 1010 |

#+BEGIN_SRC C :includes '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
printf("Item Binary");
printf("\n c " BinPat " \n 223 " BinPat, ToBin('c'), ToBin(223));
printf("\n c&223 " BinPat, ToBin('c' & 223));
printf("\n %c " BinPat, 'C', ToBin('C'));
#+END_SRC

#+RESULTS:
| Item  |   Binary |
| c     |  1100011 |
| 223   | 11011111 |
| c&223 |  1000011 |
| C     |  1000011 |
:End:

#+BEGIN_SRC C :includes  '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
// Mask, or hide, bit  6 to be a ‚Äò1‚Äô.
#define toLower(c) (c | (1 << 6))

#define toUpper(c) (c & 223)

#define times10(x) ( (x << 1)  +  (x << 3)) // Parens matter!
// x  ‚áí  2¬∑x + 8¬∑x  ‚áí  10 ¬∑ x
#+END_SRC
:Example_toLower:
#+BEGIN_SRC C :includes  '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
// printf("c " BinPat " " BinPat, ToBin('c'), ToBin(toLower('c')));
// printf("\nC " BinPat " " BinPat, ToBin('C'), ToBin(toLower('C')));

#define times10(x) ( (x << 1)  +  (x << 3))
int x = 3;
printf("\n 10¬∑%d ‚áí %d", x, times10(x));
#+END_SRC

#+RESULTS:
: 10¬∑3 ‚áí 30
:End:

How did we know is was 223?
| 0. Ninth bit is on       | ~100000000~ | ~1 << 8~   |
| 1. Negate it: Eight ones | ~11111111~  | ~(1 << 8)~ |
| 2. Sixth bit is on       | ~100000~    | ~1 << 5~   |
| 3. Xor them              | ~11011111~  | ~‚ãØ ^ ‚ãØ~    |
| 4. See it as a decimal   | ~223~       |          |

:Hide:
#+BEGIN_SRC C :includes '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
printf("\n " BinPat, ToBin(~(1 << 8)));
#+END_SRC

#+RESULTS:
: 11111111
:End:

Ironically, C has no primitive binary printing utility.

* spacing newpage                                                    :ignore:
#+latex: \newpage
* Strings, Arrays, and Pointers

  + The idea of a pointer is central to the C programming philosophy.
    - It is pointers to strings, rather than strings themselves, that're passed around
      in a C program.

  + C strings like ~s = "this"~ actually, under the hood, are /null-terminated
    arrays of characters/: The name ~s~ refers to the /address of/ the first character, the ~'t'~,
    with the array being ~'t' ‚Üí 'h' ‚Üí 'i' ‚Üí 's' ‚Üí ùüò~, where ùüò is /not/ ASCII zero
    ---whose value is 48--- but ASCII /null/ ---i.e., all bits set to 0.

  + /An array name is a pointer to the beginning of the array./
    - Yet, an array name is a constant and you can't do arithmetic with it.

#+BEGIN_SRC C :exports both
int length(char c[]) // A string is a character array
{
  // While c[l] is not an ASCII null, keep counting until.
  int l = 0;
  while( c[l] ) l++;
  return l;
}

int main()
{
  char str[] = "hello world 0123";
  printf("length(‚Äú%s‚Äù) = %d", str, length(str));
   return 0;
}
#+END_SRC

#+RESULTS:
: length(‚Äúhello world 0123‚Äù) = 16

  + ~T *p;~ ‚áí declare ~p~ to be a pointer to elements of type ~T~.
  + ~*p = v~ ‚áí ‚Äúput the value of ~v~ in the location which ~p~ points to‚Äù

We can now rewrite the length function with even less square brackets.
#+BEGIN_SRC C  :main no :includes '(\"/Users/musa/CCheatSheet/myassert.h\")
int length(char* c)
{
  char* start = c;
  while( *c ) c++; // Local copy of c is affected.
  return c - start;
}

assert(length("hello world") == 11);
#+END_SRC

* spacing COMMENT vfill :ignore:
  \vfill
* spacing COMMENT newpage                                                    :ignore:
#+latex: \newpage
* COMMENT Example code

  #+begin_src C++ :includes <stdio.h>
  int a=1;
  int b=1;
  printf("%d\n", a+b);
#+end_src

#+RESULTS:
: 2

  #+BEGIN_SRC C
  double pi = 4*atan(1);
  double r, theta, phi;
  r = sqrt(x*x+y*y+z*z);
  theta = acos(z/r) * 180.0/pi;
  phi = atan2(y,x) * 180.0/pi;
  printf("%f %f %f", r, theta, phi);
  #+END_SRC

  #+RESULTS:

#+BEGIN_SRC C :main main
int f(){ return 3;}

int main () { printf("%d", f()); return 0;}
#+END_SRC
* COMMENT Making README.md

C-c C-c: Evaluate src block.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+HTML: <h1> Easily Making CheatSheets with Org-mode </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

    ,*The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      (org-md-export-to-markdown))
)
#+END_SRC

#+RESULTS: make-readme
: README.md

#+RESULTS:
: README.md


* COMMENT footer

The first ‚Äúeval‚Äù below is convenience matter
that should be loaded whenever CheatSheet.org is opened.

The second ‚Äúeval‚Äù makes a README for the repo, whenever the file is opened,
and is then bound to ~f11~ for convenience.

# Local Variables:
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# eval: (local-set-key (kbd "<f11>") '(lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# compile-command: (my-org-latex-export-to-pdf)
# End:
