# (org-latex-export-to-pdf)

#+TITLE: C Language CheatSheet
#+MACRO: URL https://github.com/alhassy/CCheatSheet
#+MACRO: blurb Basics of the tremendously ubiquitous C language that permeates most of computing!
#+MACRO: ShowURL @@latex:{\tiny\hspace{6em}\url{ {{{URL}}} } }@@
#+AUTHOR: [[http://www.cas.mcmaster.ca/~alhassm/][Musa Al-hassy]] {{{ShowURL}}}
#+EMAIL: alhassy@gmail.com
#+TODO: Todo | spacing begin end LaTeX
#+OPTIONS: d:nil
#+INCLUDE: CheatSheet/CheatSheetSetup.org
#+PROPERTY: header-args :results replace

:Nope:
#+BEGIN_SRC C
enum days {SUN = 1, MON, TUE, WED, THU, FRI, SAT};
// Automatically: MON = 2, TUE = 3, ‚Ä¶.
#+END_SRC
:End:

:EmacsSetup:

See [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][here]] for working with C/C++/D code blocks in Org mode;
which includes examples and header argument configurations.

+ If a main method is not present in a code block then the entire block is wrapped in a trivial main function call.

+ If you want to see the expanded source code, without compiling and running it, just type C-c C-v v.

:var VARIABLE=VALUE
A global C, C++, or D variable named VARIABLE will be declared and initialized with VALUE

Possible types for VARIABLE may be:

int,
double,
string or const char*,
type[]    // type = int, double, string, const char*
type[][]  // type = int, double, string, const char*
The later type, type[][], is used for variables storing Org tables

The type[] is used for lists or vectors declared in the header.

+ ~:cmdline~ ::
    command line arguments to pass to the executable compiled from the code block.

+ ~:flags~ :: flags to pass to the compiler.

+ ~:main~ ::
        can be set to "no" to inhibit wrapping of the code block in a main function call.

+ ~:includes~ :: accepts either a single string name, or a list of names of files to #include in the execution of the code block.

+ ~:defines~ :: just like :includes but for #defines lines at the top of the code.

+ ~:libs~ :: useful for linking with a library, may be given -L/path/to/lib and -llibrary instructions.

There is no support for sessions:
As opposed to interpreted languages, which can be evaluated directly, C, C++, and D code is first compiled to an executable which is then run.
However, /An Interactive Way to C/ does provide support for sessions by using the ~currently-working-with~ mechanism (‚Ä¢ÃÄ·¥ó‚Ä¢ÃÅ)Ÿà

+ There is no directive like ~#include "stdio.h"~ because those libraries are so common that they are always included.

+ Variables may be declared outside the script. They are automatically inserted at the top of the script.

#+NAME: nice
| English | Arabic |
|---------+--------|
| zero    | sifr   |
| one     | wahid  |
| two     | ithnan |

#+header: :var mystring="Sunday" :var myint=145 :var mydouble=3.14 :var T=nice
#+BEGIN_SRC C
  // T is decared as a char*  [][] array with helpers: T_rows, T_cols, T_header, and accessor function T_h(row, col). Press C-c C-v v to see these generated names ;-)
  printf ("mystring %s\n", mystring);
  printf ("myint    %d\n", myint);
  printf ("mydouble %g\n", mydouble);
  printf ("%s %s", T_h(1, "English"), T_h(1, "Arabic") );

  // When an org table only consists of numbers, then it will be typed double[][],
  // otherwise tables are always strings, to convert a string to a numeric value, use C's atoi.
#+END_SRC

#+RESULTS:
| mystring | Sunday |
| myint    |    145 |
| mydouble |   3.14 |
| one      |  wahid |

generated code visualization through C-c C-v v is super cool.

:End:

* Arrays and Strings and Things
+ C arrays are homogeneous ---all elements are of the same type---
  and their size is static ---one cannot readily change how many elements they contain.
+ ~T name[N]~ ‚áí Declares ~name~ to be an array of type ~T~ consisting of ~N~ elements.
  - In an initialisation, ~N~ may be omitted and is then inferred.
    * E.g., ~int a[] = {2, 4, 6};~
    * E.g., ~T a[N] = {x0, ..., xM}~ for ~M < N~ initialises the first ~M~ elements and the
      remaining ~N - M~ are uninitialised, and may consist of random junk.

:Example:
#+BEGIN_SRC C
// int [] a  ‚áí  crashes!

int a [] = {9, 7, 3};
int b[3] = {4, 2, 1};

printf("%d", b[1]);

int c[10] = {3, 22, 9};
printf("\n %d and %d", c[1], c[7]);
#+end_src

#+RESULTS:
|  2 |     |   |
| 22 | and | 0 |

:End:

* LaTeX Extra, Local, Setup :ignore:

# Can be obtained from: https://github.com/alhassy/MyUnicodeSymbols
#
#+LATEX_HEADER: \usepackage{/Users/musa/MyUnicodeSymbols/MyUnicodeSymbols}

# Removing the red box that appears in "minted" when using unicode.
# Src: https://tex.stackexchange.com/questions/343494/minted-red-box-around-greek-characters
#
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \AtBeginEnvironment{minted}{\dontdofcolorbox}
#+LATEX_HEADER: \def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
#+LATEX_HEADER: \makeatother

#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \newunicodechar{ùëª}{\ensuremath{T}}
#+LATEX_HEADER: \newunicodechar{‚äï}{\ensuremath{\oplus}}
#+LATEX_HEADER: \newunicodechar{‚âà}{\ensuremath{\approx}}

#+LATEX_HEADER: \newunicodechar{‚ü™}{\ensuremath{\langle\!\langle}}
#+LATEX_HEADER: \newunicodechar{‚ü´}{\ensuremath{\rangle\!\rangle}}

#+LATEX_HEADER: \newunicodechar{ùüò}{\ensuremath{\mathbb{0}}}

* COMMENT ~\LaTeX~ commands ‚Ü¶ ~#+latex: \LaTeX~

  Execute the following block, with ~C-c C-c~ anywhere inside it,
  to hide all LaTeX specific items away so that, for example, the generated HTML
  does not show them.

  #+BEGIN_SRC emacs-lisp :results no
(defun my/replace-in-buffer (this that)
  "Replace every occurance of regexp ‚Äòthis‚Äô with ‚Äòthat‚Äô
   in the current buffer."
   (interactive)
   (save-excursion
    (beginning-of-buffer)
    (while (re-search-forward this nil t)
      (replace-match that)
    ))
)

;; Replace newline, any number of space, then room or vspace with a #+latex: beforehand.
(let (this that)
  (dolist (kp '( ( "^[ ]*\\\\room" . "#+latex: \\\\room")
         ( "^[ ]*\\\\vspace" . "#+latex: \\\\vspace")
         ( "^[ ]*\\\\newpage" . "#+latex: \\\\newpage")
         ( "^[ ]*\\\\columnbreak" . "#+latex: \\\\columnbreak")
         ))
    (setq this (car kp))
    (setq that (cdr kp))
    (my/replace-in-buffer this that)
   )
)
  #+END_SRC

  #+RESULTS:


* Adminstriva

  + All C programs consist of a series of /functions/, which have return values!

  + E.g., Assignment ~x = v~ is the function that updates the value of name ~x~
    with the value of ~v~ then terminates yielding ~v~ as a return value.

  + Semicolons act as statement /terminators/ ---in contrast to English,
    wherein they are /separators/.

  + C is whitespace agnostic: Newlines and arbitrary spaces don't matter, for the most part.
    # Every token could be on its own line if we want.

  + /Compound statements/ are formed from primitive statements by enclosing them in ~{~ curly braces ~}~.
    - Compounds may appear where-ever a single statement is allowed.

  + All keywords are in lowercase.

  + C comments do /not/ nest.
  + Include files personal files by enclosing them in "quotes", use <brackets> for
    standard library files.
  + /All/ statements must terminate with a semicolon.
  + Everything must be declared before it can be used ---sequential.
  + Characters are in-fact aliases for ASCII numerals.
    #+BEGIN_SRC C :exports results
    printf("'A' ‚âà %d  ‚â°  %s", 'A', 'A' == 65? "true" : "false");
    printf("\n'Z' ¬≠ 23  ‚âà  %c  ‚â°  %d", 'Z' - 23, 'Z' - 23);
    #+END_SRC

    #+RESULTS:
    | 'A' | ‚âà | 65 | ‚â° | true |   |    |
    | 'Z' | ¬≠ | 23 | ‚âà | C    | ‚â° | 67 |

  + C functions don't have to return anything if it's not appropriate.
    - E.g., ~exit(n)~ is the function that returns control to the operating system;
      passing it an argument ~n~, usually 0 if everything has gone smoothly and 1 if it's
      an error exit. Yet this function obviously' can't /return/ a value.

  + You must specify the type of a variable before you can use it.

  + A variable name is only meaningful in the curly brackets that define it,
    and is otherwise meaningless. This is its /scope/.
    - Whence, the same names can occur in different places to mean different things.
    - To transfer data between functions one thus uses parameter lists and return calls.

  + ~printf~, ‚Äúprint formatted‚Äù, is a /dependently-typed function/: The number and type
    of its arguments depends on its first argument, a string.
    + The number of occurrences of ‚Äò%‚Äô in the string argument is the number of additional arguments
      the ~printf~ takes.

* spacing newpage                                            :ignore:
#+latex: \newpage
* Conditionals & Assertion-Based Testing

  In C, /true ‚âà non-zero/.
  Form of the conditional:
  \vspace{-0.5em}
#+BEGIN_SRC C
if (condition)
  statementBlock
// The rest is optional.
else
  statementBlock
  #+END_SRC
  \vspace{-0.5em}
+ ~condition~ is /any/ expression that returns a numeric value:
  All numbers are treated as ‚Äòtrue‚Äô, except 0 which is considered ‚Äòfalse‚Äô.
  # - Ex, ~while(1) S~ means repeat ~S~ /forever/, or as much as possible.

  #+begin_center org
/Asserts are essentially compile-checked comments of user intentions!/
#+end_center

~assert(e)~ does nothing when expression ~e~ is true; otherwise it gives a message
showing the filename, function name, line number, and the condition ~e~ that
failed to be true.
# It is a macro defined in <assert.h>.

#+BEGIN_SRC C
#include <stdio.h>

// Disable assertions at compile time by enabling NODEBUG.
// #define NDEBUG

#include <assert.h>
// assert(n)  ‚âà  if (n) {} else ‚ü™Terminate and display error message‚ü´

int sum(int n)
{
  int total = 0, i = 0;
  while (i != n + 1)
    total += i, i++;

  return total;
}

int main ()
{
  // print-based testing
  if (1) printf("here"); else printf("there");
  printf("Sum of 0 + 1 + ‚ãØ + 99 + 100 = %d", sum(100));

  // assertion-based testing
  assert( sum(100) == 5050 );
  assert( (1 ? "here" : "there") == "here" );

  // Is completely ignored if the #define is enabled.
  // assert(0);  // Otherwise, this causes a crash.

  return 0;
}

#+END_SRC

#+RESULTS:
: hereSum of 0 + 1 + ‚ãØ + 99 + 100 = 5050

  \vspace{-0.5em}
Enforce a particular precedence order by enclosing expressions in parentheses.
#+BEGIN_SRC C
== equals          != differs from     !  not
>= at least        <= at most          && and
>  greater than    <  less than        || or
#+END_SRC

# The primary use of assertions is to ensure certain properties of data are true
# ---e.g., enforcing contracts: Checking conditions on inputs and outputs.

:Hide_my_assert:
Here's a handy utility for quick testing of my small examples.
#+BEGIN_SRC C :tangle "myassert.h" :main no
#define assert(e) int main () { printf("%s", e ? "true" : "false"); return 0; }
#+END_SRC

Example use:
#+BEGIN_SRC C :main no :includes '(\"/Users/musa/CCheatSheet/myassert.h\")
int f(n) { return n % 3; }

assert( f(0) == 0  &&  f(3) == 0  &&  f(23) == 2);
#+END_SRC

#+RESULTS:
: true

We see the results alongside writing a function, without having to form a ~main~
just to check these tests.
:End:

* spacing newpage                                            :ignore:
#+latex: \newpage

* Assignments

#+BEGIN_SRC C
/* Abbreviations */
  x ‚äï= y   ‚âà  x = x ‚äï y
  x++       ‚âà  x += 1
  --x      ‚âà  x -= 1
#+END_SRC

The increment and decrement, ~++/--~, operators may precede or follow a name:

+ If they follow a name, then their behaviour is executed /after/ the smallest context
  ---e.g., braces or conditional parentheses--- in which they occur.

+ When they precede a name, their behaviour is executed before the context in which
  they appear.

+ The order of evaluation is not specified inside a function call and so behaviour
  varies between compilers.

*Avoid using these in complex expressions, unless you know what you're doing.*

* Loops

  Here's the general form.
#+BEGIN_SRC C
while (condition)
  statementBlock

/* Abbreviations */
/* for      loop */   for(A; B; C;) S  ‚âà  A; while(B) S
/* do-while loop */   do S while B     ‚âà  S; while(B) S
#+END_SRC

do/while: The conditional is evaluated /after/ the statement has been executed
and so the statement is obeyed at least once, regardless of the truth or falsity of
the condition. This is useful for /do once, and possible more/ operations.
#+BEGIN_SRC C
int i = 0;
do printf("%d \n", i++);
while (i != 10); //Note the ending semicolon.
#+END_SRC
#+RESULTS:
| 0 |
| 1 |
| 2 |
| 3 |
| 4 |
| 5 |
| 6 |
| 7 |
| 8 |
| 9 |

* spacing newpage                                            :ignore:
#+latex: \newpage

* Arithmetic and Logic

#+begin_quote
/...and then the different branches of arithmetic ---Ambition, Distraction,
Uglification, and Derision./

---Alice's Adventures in Wonderland
#+end_quote

The modulus operator ~%~ gives the /remainder/ of a division.
#+BEGIN_SRC C :exports none
printf("rem = 10 %% 3 = %d  ‚áí  ‚àÉ quot ‚Ä¢  10 = 3 √ó quot + rem  ‚àß  quot = %d", 10 % 3, 10 / 3);
#+END_SRC

#+RESULTS:
: rem = 10 % 3 = 1  ‚áí  ‚àÉ quot ‚Ä¢  10 = 3 √ó quot + rem  ‚àß  quot = 3

+ In conditionals, one may see ~n % d~ to mean that ~n % d~ is true, i.e., is /non-zero/.
  This expresses that ~n~ is a /multiple/ of ~d~.

+ That is, numerically ~%~ yields remainders; but logically, in C, it expresses the
  is-multiple-of relationship.

When ~x~ is a number, the shift operations correspond to multiplication and
division by ~2‚Åø~, respectively.
| Left Shift  | ~x << n~ | append the bit representation of ~x~ with ~n~-many 0s             |
| Right Shift | ~x >> n~ | throw away ~n~ bits from the end of the bit representation of ~x~ |

The /bitwise/ operators /and ~&~, or ~|~, not ~!~,/ and /xor/ ~^~ operate at the bit representation
of an item. For example, the ASCII code of a character consists of 7 bits where
| _Bit_ | _Function_                            |
|   7 | 0 digit, 1 letter                   |
|   6 | 0 upper case, 1 digit or lower case |
|   5 | 0 for a-o, 1 for digit or p-z       |

Whence, to convert a character to uppercase it suffices to change bit 5 to be a 0
and leave the other bits alone. That is, to perform a bitwise /and/ with the binary
number /11011111/, which corresponds to the decimal number 223.

:Hide_binary_priniting:
From [[https://stackoverflow.com/a/3208376/3550444][stackoverflow]],
#+BEGIN_SRC C :tangle "BinaryPrinting.c" :main no
// Super buggy! E.g., try printing 1 ^ 1.

#define BinPat "%c%c%c%c%c%c%c%c"

#define ToBin(byte)  \
  ((unsigned int)byte & 0x80 ? '1' : '0'), \
  ((unsigned int)byte & 0x40 ? '1' : '0'), \
  ((unsigned int)byte & 0x20 ? '1' : '0'), \
  ((unsigned int)byte & 0x10 ? '1' : '0'), \
  ((unsigned int)byte & 0x08 ? '1' : '0'), \
  ((unsigned int)byte & 0x04 ? '1' : '0'), \
  ((unsigned int)byte & 0x02 ? '1' : '0'), \
  ((unsigned int)byte & 0x01 ? '1' : '0')

#define printBin(n) printf(BinPat, ToBin(n));
#+END_SRC

#+BEGIN_SRC C :includes '(<stdio.h> \"/Users/musa/CCheatSheet/BinaryPrinting.h\")
for(int i = 0; i < 11; i++)
  {printf("\n%d ‚áí ", i); printBin(i);}
#+END_SRC

#+RESULTS:
|  0 | ‚áí |    0 |
|  1 | ‚áí |    1 |
|  2 | ‚áí |   10 |
|  3 | ‚áí |   11 |
|  4 | ‚áí |  100 |
|  5 | ‚áí |  101 |
|  6 | ‚áí |  110 |
|  7 | ‚áí |  111 |
|  8 | ‚áí | 1000 |
|  9 | ‚áí | 1001 |
| 10 | ‚áí | 1010 |

#+BEGIN_SRC C :includes '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
printf("Item Binary");
printf("\n c " BinPat " \n 223 " BinPat, ToBin('c'), ToBin(223));
printf("\n c&223 " BinPat, ToBin('c' & 223));
printf("\n %c " BinPat, 'C', ToBin('C'));
#+END_SRC

#+RESULTS:
| Item  |   Binary |
| c     |  1100011 |
| 223   | 11011111 |
| c&223 |  1000011 |
| C     |  1000011 |
:End:

#+BEGIN_SRC C :includes  '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
// Mask, or hide, bit  6 to be a ‚Äò1‚Äô.
#define toLower(c) (c | (1 << 6))

#define toUpper(c) (c & 223)

#define times10(x) ( (x << 1)  +  (x << 3)) // Parens matter!
// x  ‚áí  2¬∑x + 8¬∑x  ‚áí  10 ¬∑ x
#+END_SRC
:Example_toLower:
#+BEGIN_SRC C :includes  '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
// printf("c " BinPat " " BinPat, ToBin('c'), ToBin(toLower('c')));
// printf("\nC " BinPat " " BinPat, ToBin('C'), ToBin(toLower('C')));

#define times10(x) ( (x << 1)  +  (x << 3))
int x = 3;
printf("\n 10¬∑%d ‚áí %d", x, times10(x));
#+END_SRC

#+RESULTS:
: 10¬∑3 ‚áí 30
:End:

How did we know is was 223?
| 0. Ninth bit is on       | ~100000000~ | ~1 << 8~   |
| 1. Negate it: Eight ones | ~11111111~  | ~~(1 << 8)~ |
| 2. Sixth bit is on       | ~100000~    | ~1 << 5~   |
| 3. Xor them              | ~11011111~  | ~‚ãØ ^ ‚ãØ~    |
| 4. See it as a decimal   | ~223~       |          |

:Hide:
#+BEGIN_SRC C :includes '(\"/Users/musa/CCheatSheet/BinaryPrinting.h\")
printf("\n " BinPat, ToBin(~(1 << 8)));
#+END_SRC

#+RESULTS:
: 11111111
:End:

Ironically, C has no primitive binary printing utility.

* spacing newpage                                                    :ignore:
#+latex: \newpage
* Strings, Arrays, and Pointers

  + The idea of a pointer is central to the C programming philosophy.
    - It is pointers to strings, rather than strings themselves, that're passed around
      in a C program.

  + C strings like ~s = "this"~ actually, under the hood, are /null-terminated
    arrays of characters/: The name ~s~ refers to the /address of/ the first character, the ~'t'~,
    with the array being ~'t' ‚Üí 'h' ‚Üí 'i' ‚Üí 's' ‚Üí ùüò~, where ùüò is /not/ ASCII zero
    ---whose value is 48--- but ASCII /null/ ---i.e., all bits set to 0.

    - Note that null ùüò is denoted by ~'\0'~ and has /value/ 0, i.e., false, so
      conditions of the form ~p != '\0'~ are the same as ~p~.

  + /An array name is a pointer to the beginning of the array./
    - Yet, an array name is a constant and you can't do arithmetic with it.

#+BEGIN_SRC C :exports both
int length(char c[]) // A string is a character array
{
  // While c[l] is not an ASCII null, keep counting until.
  int l = 0;
  while( c[l] ) l++;
  return l;
}

int main()
{
  char str[] = "hello world 0123";
  printf("length(‚Äú%s‚Äù) = %d", str, length(str));
   return 0;
}
#+END_SRC

#+RESULTS:
: length(‚Äúhello world 0123‚Äù) = 16

  + ~T *p;~ ‚áí declare ~p~ to be a pointer to elements of type ~T~.
  + ~*p = v~ ‚áí ‚Äúput the value of ~v~ in the location which ~p~ points to‚Äù

We can now rewrite the length function with even less square brackets.
#+BEGIN_SRC C  :main no :includes '(\"/Users/musa/CCheatSheet/myassert.h\")
int length(char* c)
{
  char* start = c;
  while( *c ) c++; // Local copy of c is affected.
  return c - start;
}

assert(length("hello world") == 11);
#+END_SRC

* Floats & Other Types

 + float: Representing huge numbers to tiny fractions.
 + double: Like float, but greater precision.
 + int: The integers; it has 2 /subtypes/; namely short, long, and unsigned.
   - Short and long allocate less (half) or more (twice) memory, respectively.
   - Unsigned means we omit negative numbers, and therefore have twice as many
     non-negative numbers since the sign is no longer a necessary place-holder.
     * Also useful when negative integers are unreasonable for the current task.

Type aliases: ~typedef existingType newName;~
#+BEGIN_SRC C
// A named product: String √ó ‚Ñ§ √ó ‚Ñù   having names  name, age, height.
struct entry
{
  char   name[30];
  short  age;
  float  height;
}; // Note that this is a statement

// Alias for readability.
typedef   struct entry   Person;

int main()
{                                            // Exponent form for numbers.
  struct entry qasim = {"qasim", 0, 613e-2}; // 613e-2 ‚áí 613 √ó 10‚Åª¬≤ ‚áí 6.13
  Person q = qasim;
  q.age = 23;

  printf("Hello! My name is %s and I'm %d years old, being %f ft tall",
     q.name, q.age, q.height);
  return 0;
}
#+END_SRC

#+RESULTS:
| Hello! My name is qasim and I'm 23 years old | being 6.130000 ft tall |

* Forming Numbers using Octal & Hexadecimal

Numbers that begin with a 0 are interpreted as octal and those beginning with 0x or 0X
are hexadecimal. These forms are obtained from binary by grouping using 3 bits
and 4 bits, respectively. E.g., ~129 ‚âà 0201 ‚âà 0x81~ since:

+ 129 ‚Üí‚ü®binary‚ü© 10 000 001 ‚Üí‚ü®octal‚ü© 2 0 1
+ 129 ‚Üí‚ü®binary‚ü© 1000 0001  ‚Üí‚ü®hexadecimal‚ü© 8 1

Indeed:
#+BEGIN_SRC C :exports both
int x = 129, y = 0201, z = 0x81, zz = 0X81, b = (x == y) && (x == zz);
printf("%d ‚âà %d ‚âà %d; %d", x, y, z, b);
#+END_SRC

#+RESULTS:
: 129 ‚âà 129 ‚âà 129; 1

* The Preprocessor

  The preprocessor performs alterations to a program /before/ it is compiled; e.g.,
  the following ensures the replacement of every occurrence of ~this(‚ãØ, ‚ãØ)~ after it with
  whatever ~that~ is.
  #+BEGIN_SRC C
#define this(arg1, arg2)  that
#+End_SRC

  + All preprocessor commands are preceded by the ~#~ symbol.

  + One generally defines useful constants or abbreviations this way, and if they have
    a collection of such parameters or utilities in some file, then they can
    /copy-paste/ them into the current program file by using ~#include~ as mentioned
     before.

* Array initialisation

#+BEGIN_SRC C :includes <assert.h>
int nums[] = {12, 144, 1972};
assert( nums[0] == 12 );
#+END_SRC

* Pointer initialisation

#+BEGIN_SRC C :exports both
int a[30], *p;

// Make p point to the beginning of the array a, since a is itself a pointer to the
// beginning of the array.
p = a;

// Determine the actual machine address of a variable by predicing it with &.
int fred;
p = &fred;

// If we need to know exactly where in the machine C had decidede to allocate space
// to fred, we need only to print out p; whence & is read ‚Äúaddress of‚Äù.
printf("%p", p);
#+END_SRC

#+RESULTS:
: 0x7ffee36348ac


Since the name of an array is itself a pointer to the beginning of an array, we have
| arr ‚âà &arr[0] |

#+BEGIN_SRC C :includes <assert.h>
// Find furthest points of ‚Äòint a[N-1]‚Äô that are identical.
#define N 12
int a[] = {9,8,1,2,3,4,4,3,2,1,7,6};

int * p = a, *q = &a[N-1];
while(*p != *q) p++, q--;

assert(*p == a[2] && *q == a[9]);
#+END_SRC


Before C99, function return types could be omitted with the understanding that the
default is ~int~. However, ~main~ still needs its return type. The following works with
many warnings.
#+BEGIN_SRC C :includes <assert.h> :exports both
f() {return 9; }
g() {return 'c'; } // Remember that chars are actually numbers.

int main() { printf("%d", f() + g()); return 0; }
#+END_SRC

#+RESULTS:
: 108

* Input --getting things /into/ the machine

  + ~getchar~ returns the next character input from the keyboard.

#+BEGIN_SRC C :tangle (not-currently-working-with)
#include <stdio.h>

int main()
{
  printf("Please enter a character: ");
  char c = getchar();
  printf("You entered: %c", c);
  printf("\nBye\n");

  return 0;
}
#+END_SRC

Let's extend ~getchar~ to work on buffers of length, say, 20:
#+BEGIN_SRC C :tangle (currently-working-with)
#include <stdio.h>

#define BUFFER_LENGTH 10

int main()
{
  printf("Please enter a string, only first %d chars or newline will be read: \n\t\t",
         BUFFER_LENGTH);
  char cs[BUFFER_LENGTH];
  int keep_reading = 1;
  char * p = cs;
  while(keep_reading && p < cs + BUFFER_LENGTH)
    {*p = getchar(); if (*p == '\n') keep_reading = 0; else p++;}

  ,*p = '\0'; // Strings are a null-terminated arrays of chars.

  printf("\nYou entered: %s", cs);
  printf("\nBye\n");

  return 0;
}
#+END_SRC

* Interpreter for C

  *Adapted* to cater to interactive programs
  from /An Interactive Way to C/ and my init's ~my/org-run-haskell~ which really
  ought to be extracted into its own piece.

#+BEGIN_SRC emacs-lisp :tangle InteractiveWayToC.el
;; Every source block is in ‚Äòfocus‚Äô when the variables ~NAME~ and ~NAMECode~ refer to it.

(cl-defun currently-working-with (&optional (name (file-name-sans-extension (buffer-name))))
  "Provide the name (without extension) of the source block's resulting file.
   The name is then tied to the ‚ÄúNAMECode‚Äù global variable utilised
   by the ‚Äúshow-code‚Äù method, <f7>, and the ‚Äúinterpret‚Äù command's global variable ‚ÄúNAME‚Äù.

   If no argument is provided, we use ‚Äú‚ü™BufferName‚ü´.c‚Äù as default file name.
  "
  (setq NAME name)
  (setq NAMECode (concat name ".c"))
)

(defun not-currently-working-with (&optional name)
  "When ‚Äú:tangle fn‚Äù has ‚Äúfn‚Äù being the empty string, the tangle does not transpire.
   As such, it is as if we are not actually generating the source block.

   This operation only returns the empty string and does not alter any existing state.
   If we alter state, then earlier invocations to (currently-working-with) are rendered
   useless!
  "

  ""   ;; Our return value.
)

(defun interpret () "Execute focused source blocks in a new buffer."
  (interactive)
  (save-buffer)
  (org-babel-tangle)

  (let ((buf (concat "*Interactive Way to C* " NAME))
       (kill-buffer-query-functions nil))

    (ignore-errors (kill-buffer buf))
    (async-shell-command
    (concat
     "cd " default-directory "; NAME=" NAME " ; gcc $NAME.c -o $NAME.exe ; ./$NAME.exe")
    buf)
  )
  ;; (insert-focused-name)
  ;; Go back to the literate buffer.
  (other-window 1))

(local-set-key (kbd "<f6>") 'interpret)
#+END_SRC

#+RESULTS:
: interpret

  Example use; press ~f6~.
  #+BEGIN_SRC C :tangle (not-currently-working-with)
#include <stdio.h>

int main() {printf("Hello"); return 0; }
#+END_SRC

*Remember*: All ~currently-working-with~ tagged blocks are interpreted; usually
you want to turn some of these off via ~not-currently-working-with~.

* spacing COMMENT vfill :ignore:
  \vfill
* spacing COMMENT newpage                                                    :ignore:
#+latex: \newpage
* COMMENT Example code

  #+begin_src C++ :includes <stdio.h>
  int a=1;
  int b=1;
  printf("%d\n", a+b);
#+end_src

#+RESULTS:
: 2

  #+BEGIN_SRC C
  double pi = 4*atan(1);
  double r, theta, phi;
  r = sqrt(x*x+y*y+z*z);
  theta = acos(z/r) * 180.0/pi;
  phi = atan2(y,x) * 180.0/pi;
  printf("%f %f %f", r, theta, phi);
  #+END_SRC

  #+RESULTS:

#+BEGIN_SRC C :main main
int f(){ return 3;}

int main () { printf("%d", f()); return 0;}
#+END_SRC
* COMMENT Making README.md

C-c C-c: Evaluate src block.

#+NAME: make-readme
#+BEGIN_SRC emacs-lisp
(with-temp-buffer
    (insert
    "#+EXPORT_FILE_NAME: README.md
     ,#+HTML: <h1> Easily Making CheatSheets with Org-mode </h1>
     ,#+OPTIONS: toc:nil d:nil
     # Toc is displayed below at a strategic position.

     {{{blurb}}}

    ,*The listing sheet, as PDF, can be found
     [here]({{{URL}}}/blob/master/CheatSheet.pdf)*,
     while below is an unruly html rendition.

     This reference sheet is built around the system
     https://github.com/alhassy/CheatSheet.

     ,#+TOC: headlines 2
     ,#+INCLUDE: CheatSheet.org
    ")

    ;; No code execution on export
    ;; ‚ü™ For a particular block, we use ‚Äú:eval never-export‚Äù ‚ü´
    ;;
    (let ((org-export-use-babel nil))
      (org-mode)
      (org-md-export-to-markdown))
)
#+END_SRC

#+RESULTS: make-readme
: README.md

#+RESULTS:
: README.md


* COMMENT footer

The first ‚Äúeval‚Äù below is convenience matter
that should be loaded whenever CheatSheet.org is opened.

The second ‚Äúeval‚Äù makes a README for the repo, whenever the file is opened,
and is then bound to ~f11~ for convenience.

# Local Variables:
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# eval: (local-set-key (kbd "<f11>") '(lambda () (interactive) (org-babel-goto-named-src-block "make-readme") (org-babel-execute-src-block) (outline-hide-sublevels 1)))
# eval: (progn (visual-line-mode t) (require 'ox-extra) (ox-extras-activate '(ignore-headlines)))
# compile-command: (my-org-latex-export-to-pdf)
# End:
